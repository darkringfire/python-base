"""
Задание по программированию: Гражданская оборона

Штаб гражданской обороны Тридесятой области решил обновить план спасения на
случай ядерной атаки. Известно, что все n селений Тридесятой области находятся
вдоль одной прямой дороги. Вдоль дороги также расположены m бомбоубежищ, в
которых жители селений могут укрыться на случай ядерной атаки.

Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
необходимо для каждого селения определить ближайшее к нему бомбоубежище.

Формат ввода
В первой строке вводится число n - количество селений (1 <= n <= 100000).
Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
расстояние от начала дороги до i-го селения. В третьей строке входных данных
задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка
содержит m различных целых чисел, i-е из этих чисел задает расстояние от начала
дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 10⁹.
Селение и убежище могут располагаться в одной точке.

Формат вывода
Выведите  n чисел - для каждого селения выведите номер ближайшего к нему
бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они
заданы во входных данных.

Указание
Создайте список кортежей из пар (позиция селения, его номер в исходном списке),
а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.

Перебирайте селения в порядке возрастания.

Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
выбрать ближайшее. При переходе к следующему селению не обязательно искать
ближайшее бомбоубежище с самого начала. Его можно искать начиная с позиции,
найденной для предыдущего города. Аналогично, не нужно искать подходящее
бомбоубежище до конца списка бомбоубежищ: достаточно найти самое близкое. Если
Вы неэффективно реализуете эту часть, то решение тесты не пройдет.

Для хранения ответа используйте список, где индекс будет номером селения, а по
этому индексу будет запоминаться номер бомбоубежища.
"""


def sorted_tuples(cities):
    return sorted(enumerate(cities), key=(lambda t: t[1]))


def dist(city, shelter):
    return abs(city[1] - shelter[1])


def is_next_nearer(city, shelters, sh_n):
    cur_dist = dist(city, shelters[sh_n])
    next_dist = dist(city, shelters[sh_n+1])
    return next_dist < cur_dist


def main():
    # input
    n = int(input())
    cities = list(map(int, input().split()))
    m = int(input())
    shelters = list(map(int, input().split()))

    # create sorted lists
    cities_sorted = sorted_tuples(cities)
    shelters_sorted = sorted_tuples(shelters)

    cities_shelters = []
    sh_n = 0
    for city in cities_sorted:
        while sh_n+1 < m and \
                is_next_nearer(city, shelters_sorted, sh_n):
            sh_n += 1
        cities_shelters.append((city[0], shelters_sorted[sh_n][0]))
    print(*list(map(lambda t: t[1]+1, sorted(cities_shelters))))


main()
